               <h1 class="post-full-title">So you want to revoke macaroons</h1>

                <p class="post-full-custom-excerpt">Macaroons are bearer tokens.
As for every bearer token, the question of revocation is important: how can we stop a token from being accepted by services?</p>

                <div class="post-full-byline">

                    <section class="post-full-byline-content">

                        <ul class="author-list">
                            <li class="author-list-item">

                                <div class="author-card">
                                    <div class="author-profile-image"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"/></g></svg>
</div>
                                    <div class="author-info">
                                        <h2>Clément Delafargue</h2>
                                        <p>Read <a href="/author/clement/">more posts</a> by this author.</p>
                                    </div>
                                </div>

                                <a href="/author/clement/" class="author-avatar author-profile-image"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"/></g></svg>
</a>

                            </li>
                        </ul>

                        <section class="post-full-byline-meta">
                            <h4 class="author-name"><a href="/author/clement/">Clément Delafargue</a></h4>
                            <div class="byline-meta-content">
                                <time class="byline-meta-date" datetime="2022-05-02">2 May 2022</time>
                                <span class="byline-reading-time"><span class="bull">&bull;</span> 11 min read</span>
                            </div>
                        </section>

                    </section>


                </div>
            </header>

            <figure class="post-full-image">
                <img
                    srcset="https://s3-eu-west-1.amazonaws.com/tech-blog-fretlink/2022/05/its-just-been-revoked.jpg 300w,
                            https://s3-eu-west-1.amazonaws.com/tech-blog-fretlink/2022/05/its-just-been-revoked.jpg 600w,
                            https://s3-eu-west-1.amazonaws.com/tech-blog-fretlink/2022/05/its-just-been-revoked.jpg 1000w,
                            https://s3-eu-west-1.amazonaws.com/tech-blog-fretlink/2022/05/its-just-been-revoked.jpg 2000w"
                    sizes="(max-width: 800px) 400px,
                        (max-width: 1170px) 1170px,
                            2000px"
                    src="https://s3-eu-west-1.amazonaws.com/tech-blog-fretlink/2022/05/its-just-been-revoked.jpg"
                    alt="So you want to revoke macaroons"
                />
            </figure>

            <section class="post-full-content">
                <div class="post-content">
                    <h1 id="so-you-want-to-revoke-macaroons">So you want to revoke macaroons</h1><p>Macaroons are bearer tokens, introduced in <a href="https://research.google/pubs/pub41892.pdf">Macaroons: Cookies</a><br><a href="https://research.google/pubs/pub41892.pdf">with Contextual Caveats for Decentralized Authorization in the</a> <br><a href="https://research.google/pubs/pub41892.pdf">Cloud</a>. There is a <a href="https://github.com/rescrv/libmacaroons">reference implementation</a> that pins down the details.</p><p>As for every bearer token, the question of revocation is important: how can we stop a token from being accepted by services? The usual challenge with revocation is to distribute the list of revoked tokens to every service. In the case of macaroons, there is an extra challenge: uniquely identifying a token. This is what I’ll talk about in this article. Distributing revocation lists is a really interesting subject, but is highly context-dependent, and abundantly covered elsewhere.</p><p>Here is what we’ll cover:</p><ul><li>first a recap about bearer tokens and their tradeoffs;</li><li>then a description of macaroons, with details relevant to revocation;</li><li>then we will cover two possible solutions;</li><li>finally some advice about what can be done, and what should be done now.</li></ul><h2 id="the-tradeoff-of-bearer-tokens">The tradeoff of bearer tokens</h2><p>Bearer tokens don’t need shared state: they are supposed to be verifiable without accessing a central authority. It is usually done through the use of cryptographic tools, such as <a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a>, or <a href="https://en.wikipedia.org/wiki/Digital_signature">digital signatures</a>.</p><p>The benefit of not having shared state is that each service can independently trust a bearer token without performing extra network requests. This removes a single point of failure and makes decentralized systems easier, but the drawback is…<br><em>not having shared state</em>.</p><p>With session tokens, everything is immediate, because the session is the single source of truth. Bearer tokens trade immediate updates for simpler semantics and more robustness.</p><p>In particular, revoking access is simple with session tokens: deleting the session automatically revokes all linked tokens, with no latency.</p><h3 id="revocation-lists-problems">Revocation lists problems</h3><p>Revoking a bearer token is harder: since each service can verify them independently, you need to push down a list of revoked tokens to each service. This means that revoking access can take much longer, depending on the precise mechanism used to distribute the revocation list.</p><h4 id="latency">Latency</h4><p>Of course, reducing revocation latency is extremely important. If there’s a leak, we want to plug it as fast as possible, reducing the vulnerability window as much as possible. In trying to do so, we still must be careful about not negating the benefits of bearer tokens. For instance, it might be tempting to contact a revocation server every time a token is verified. That reduces latency to zero, but this sneakily reintroduces a network dependency and a single point of failure, with much more complexity.</p><h4 id="list-size">List size</h4><p>Once a token is revoked, you need to reject it until the heat death of the universe (or more realistically until your rewrite everything to use shiny new tech). This means that the revocation list can only grow.  Not an issue at first but it can become an issue after a couple years (especially if you resist the urge to rewrite everything with shiny new tech).</p><p>One common way to mitigate this is to add TTLs to all your tokens, this way you can remove them from the revocation list once they are expired.</p><h3 id="revoking-macaroons">Revoking macaroons</h3><p>In the case of macaroons, we have an extra challenge: how do we uniquely identify a macaroon? Just listing the macaroon is both too broad and not broad enough, as you will see.</p><h2 id="what-is-a-macaroon">What is a macaroon?</h2><p>The main benefit of macaroons is that they allow <em>offline attenuation</em>: given a token, its holder can craft a new token, with more restrictions, <em>without</em> interacting with the token emitter.</p><h3 id="seriously-what-is-a-macaroon">Seriously, what <em>is</em> a macaroon?</h3><p>A macaroon is a token made of several parts:</p><ul><li>a <em>key identifier</em>, that provides the base scope for the token</li><li>a <em>location,</em> a freeform field that is not cryptographically signed and is purely informational. We will ignore it from now on.</li><li>a series of <em>caveats</em>, restrictions on this base scope</li><li>a <em>signature</em> that proves the macaroon comes from a trusted authority</li></ul><p>The <em>key identifier</em> and the <em>caveats</em> are freeform bytestrings. They usually contain text, but they can contain anything.</p><p>Usually it is enough to know that the <em>key identifier</em> is the only part that you can trust as coming from the authority and that the caveats can be freely added to a given token, but not removed. In our case, we will have to dig a bit more into the cryptography part to understand how to identify a macaroon.</p><p>Verifying a macaroon involves two operations:</p><ul><li>verifying the signature (more about this later);</li><li>making sure each <em>caveat</em> is <em>discharged</em>.</li></ul><p>Let’s clarify what <em>discharging a caveat</em> means and how it’s done in practice.  A <em>caveat</em> is a restriction carried by the token: the token is only valid if the verifier can prove the property it ensures is satisfied. A common caveat is <code>time &lt; 2022-04-30T00:00:00Z</code>. It means "this token is only valid as long as the current datetime is before April 30, 2022, midnight UTC. For a macaroon to be valid, all of its <em>caveats</em> must be discharged. To discharge <em>caveats</em>, the verifying party can supply <em>verifiers</em>. A <em>verifier </em>is a function taking a <em>caveat</em> (a bytestring) and returning a boolean (<code>true</code> if the verifier understands the <em>caveat</em> and can discharge it, <code>false</code> if it cannot understand it, or if it understands it and can’t discharge it). Here is how it looks like in haskell:</p><pre><code class="language-haskell">timeVerifier :: UTCTime -&gt; ByteString -&gt; Bool
timeVerifier now = fromMaybe False $ do
  dateTimeStr &lt;- BS.toString &lt;$&gt; BS.stripPrefix "time &lt; "
  validBefore &lt;- Time.iso8601ParseM dateTimeStr
  pure $ now &lt; validBefore
  
verifyMacaroon :: Macaroon -&gt; IO Bool
verifyMacaroon macaroon = do
  now &lt;- Time.getCurrentTime
  pure $ verify secret macaroon [timeVerifier now]
</code></pre><p>Here, <code>verify</code> performs both verifications: it checks the signature, and it tries to discharge every <em>caveat</em>.</p><h4 id="third-party-caveats">Third-party caveats</h4><p>The <em>caveats</em> I have described above are called <em>first-party</em> caveats. It means they can be discharged directly by the service who verifies the macaroon. Macaroons also describe another kind of <em>caveat</em> (and it may be their most important innovation), called <em>third-party</em> caveat. It is a <em>caveat</em> that can only be discharged by a third-party service. In practice, it means that the macaroon holder has to contact the third-party service to get a <em>proof</em> that the caveat can be discharged, in the form of (you guessed it) <em>another macaroon</em> (which, crucially, can contain <em>caveats</em> of its own). The client has then to send both macaroons (serializing multiple macaroons is not spec'd in the paper, nor provided by the <a href="https://github.com/rescrv/libmacaroons">reference implementation</a>) to the service that will then be able to discharge the third-party <em>caveats</em> with the attached <em>discharge</em> macaroons.</p><p>This is a very powerful mechanism, as it allows verification to be split across multiple services, <em>without requiring the services to talk to each other</em>. The only requirement is a shared secret between services. This is very useful when coordinating services across multiple independent entities (for example restricting access of a Dropbox link to Facebook friends).<br>Within services of a single entity, however, it tends to be overkill, as strong de-coupling of services is not as useful. Sadly, I have heard of a couple macaroons deployments going this way (because it is tempting, fun and interesting), and then suffering from complexity. Interestingly enough, I have not heard of cross-company macaroons deployments.</p><h4 id="macaroon-signatures">Macaroon signatures</h4><p>Now, for the signature part. Macaroons are based on HMACs: this allows to sign a payload with a shared secret: the verifying party computes the expected result and checks if it is the same as the provided signature.</p><p>To sign a macaroon, the emitter proceeds as follows:</p><ul><li>first it takes the HMAC of (something computed from) the key identifier, signed by the macaroon secret;</li><li>for each caveat, it takes the HMAC of the caveat, signed by the previous signature</li><li>it bundles the <em>identifier</em>, the <em>caveats</em> and the final signature together</li></ul><p>With this, you should be able to convince yourself that holding a token allows you to add a <em>caveat</em> without knowing the shared secret, and that it’s impossible to remove or reorder <em>caveats</em> without knowing the shared secret.</p><p>To verify a macaroon, the verifying party computes the expected signature and checks if it matches the one carried by the macaroon.</p><h2 id="part-two-how-to-identify-a-macaroon">Part two: how to identify a macaroon</h2><p>Okay, so now your services maintain a revocation list. Good. What are you going to put in it?</p><p>You could store the whole macaroon but that is not super convenient, and you would need to be careful with the revocation list, since macaroons are sensitive tokens after all.</p><h3 id="using-a-third-party-caveat-tied-to-an-external-revocation-service">Using a third-party caveat tied to an external revocation service</h3><p>The macaroons paper does not cover revocation explicitly, but hints at it in an example of how third-party <em>caveats</em> could be used: when created, a macaroon can be attenuated with a third-party <em>caveat</em> that mandates a proof that the macaroon has not been revoked. In practice, it means that the client has to call out to a revocation server, to obtain a proof that the current token has not been revoked (how?), and bundle this proof with the original macaroon before finally sending the request to the service.<br>For. Every. Single. Request.</p><p>That sounds… cumbersome. Of course the client can cache validity proofs, but that still makes the client code way more cumbersome. The discharging of the third-party caveat can also be shifted to the service, but at that point, why use a third-party caveat at all? The service can just call the revocation server itself.</p><p>All in all, while this way of doing things is explicitly advised in the paper, I really don’t think it’s a convenient way to do things. Worse, the complexity it brings might lead you to doing unfortunate things like calling the revocation service at every request (thus negating all benefits of using bearer tokens), without really realizing it.</p><h3 id="using-the-key-identifier">Using the <em>key identifier</em></h3><p>You could reject all macaroons with a given <em>key identifier</em>. In some cases it is a practical solution: if the <em>key identifier</em> is a session id, you end up in the session token case: you nuke the session and force a re-auth.</p><p>Some macaroon deployments will work well with this setup, but for pure bearer macaroons it will be too broad: if the <em>key identifier</em> only identifies a user, then the user would be banned forever. Not satisfying.</p><h3 id="using-the-signature">Using the signature</h3><p>Another solution would be to store the macaroon signature: it’s computed from the key id and the caveats, so it allows you to identify a given macaroon.</p><p>All good then? Sadly, no. Such a system would be trivial to circumvent.</p><p>Macaroons are made to be restricted with <em>caveats</em>. So given a macaroon, you can mint a new one with an arbitrary <em>caveat</em> (say, a TTL caveat that expires in a thousand years), and get a new macaroon, with a new signature.</p><p>Thankfully, checking signatures can still be useful: the signature carried by a macaroon can be changed by adding a <em>caveat</em>, but during the process of verifying a macaroon signature, you compute all intermediate signatures. So it is possible to check each intermediate signature against a revocation list. This solution is great because it means that if you mint a restricted macaroon from a base macaroon, and want to revoke only this restricted macaroon, you can do it without revoking the base one. Conversely, if you revoke a macaroon, all of its derived macaroons are automatically revoked.</p><p>This sounds like a great solution, but there are two issues with it:</p><ul><li>macaroon libraries don't expose intermediate signatures</li><li>you're still not able to <em>uniquely</em> identify macaroons</li></ul><p>Macaroon generation is deterministic: there is no randomness involved. With the same key id and caveats, you'll get the same signature. So when you revoke a macaroon based on its signature (or any intermediate signature), you don't revoke just this macaroon, but all macaroons generated with the same key id and caveats.</p><h4 id="with-ttls">With TTLs</h4><p>Now, if you generate macaroons with TTLs, you get closer to unicity: revoking a macaroon will only revoke macaroons with the same key id, caveats (and this means that have been generated at the exact same moment, depending on the precision of the timestamp carried by the TTL caveat).</p><p>It is still not completely satisfying, since it is rather accidental, absolutely not random, and because some macaroons may not have TTLs (API-to-API macaroons for instance).</p><h3 id="with-a-dedicated-id">With a dedicated id</h3><p>The best solution to make a macaroon unique is to include a random id upon generation. A simple way to do it is to add a dedicated caveat. Once you have that, every macaroon is unique when generated. You can do the same for derivation: if you want to be able to uniquely revoke a derived macaroon, you need to include a new unique id along with the caveats you're adding.</p><pre><code>not_revoked = &lt;random_blob&gt;
</code></pre><p>But now, if you're adding unique ids in caveats, you don't need access to intermediate signatures any more: the verifier for these caveats can check if they are not revoked. This is coarser grained than checking signatures (you can only target ids, not single out caveats, and if you have a macaroon with no id, then you can't do anything), but that can be easily implemented without needing any library change.</p><p>Here is how it could look like in haskell:</p><pre><code class="language-haskell">revocationValidator :: (ByteString -&gt; RevocationResult)
                    -&gt; ByteString
                    -&gt; Bool
revocationValidator isRevoked caveat =
  let rid = BS.stripPrefix "not_revoked = " caveat
   in case isRevoked &lt;$&gt; rid of
        Nothing    -&gt; False
        -- ^ this is not a revocation caveat
        Just True  -&gt; False
        -- ^ this id has been revoked, the caveat is not discharged
        Just False -&gt; True
        -- ^ this id has not been revoked, the caveat can be discharged
</code></pre><p>Just remember that, due to how macaroons work, if you don't have a revocation caveat, then the revocation check will not run. Embedding a revocation id in newly created macaroons is not enough, you’ll need to add a revocation check to all existing long-lived macaroons, and, after some time start manually checking for the presence of revocation ids as part of the verification pipeline.</p><pre><code class="language-haskell">hasRevocationId :: Macaroon -&gt; Bool
hasRevocationId macaroon =
  let isRevocationCaveat bs = BS.startsWith bs "not_revoked = "
   in any isRevocationCaveat $ caveats macaroon

verifyMacaroon :: (ByteString -&gt; RevocationResult)
               -&gt; [ByteString -&gt; Bool]
               -&gt; Macaroon
               -&gt; IO Bool
verifyMacaroon isRevoked verifiers macaroon = do
  now &lt;- Time.getCurrentTime
  let allVerifiers = timeVerifier now
                   : revocationVerifier isRevoked
                   : verifiers
  pure $ hasRevocationId macaroon
      &amp;&amp; verify secret macaroon allVerifiers
</code></pre><p>Having to embed this kind of manual check to macaroons validation is one of the reasons why you <em>really</em> should build an auth layer on top of macaroons and not just use them directly.</p><h1 id="what-you-should-do-now">What you should do now</h1><p>The first question you should ask yourself is "why don't I just use session tokens?". Using session tokens instead of bearer tokens makes <em>a lot</em> of things easier.</p><p>But if you're set on bearer tokens, particularly macaroons, then read on.</p><h2 id="use-ttls">Use TTLs</h2><p>Make sure you use TTLs. For tokens automatically delivered, bake it in the delivery process. Short-lived tokens can be coupled with a refresh token update mechanism. When using long-lived tokens, adding a TTL right before sending them on the wire mitigates the consequences of a leak.</p><p>TTLs won't make revocation go away, but it will definitely make it easier and restrict the scope of security issues.</p><h2 id="embed-unique-ids-in-macaroons">Embed unique ids in macaroons</h2><p>Even if you don't end up implementing revocation capabilities, being able to identify tokens will help your ops team at some point. Once you've done that, not only you will be able to trace the use of tokens and know where they come from, but you'll also be able to roll out revocation in the future without having to renew every token.</p><h3 id="ensure-that-tokens-are-revocable">Ensure that tokens are revocable</h3><p>Adding revocation ids to new tokens is not enough. For short-lived tokens, you can wait a bit and now every token will have a revocation id, but for long-lived tokens you will have to go and replace them with fresh tokens with revocation ids.</p><p>The next step will be to make sure verified tokens have revocation ids. You can start by logging a warning when you see an unrevocable token. After a while, when logs have become quiet, you can flip the switch and start refusing unrevocable tokens altogether.</p><h2 id="think-about-how-to-distribute-revocation-lists">Think about how to distribute revocation lists</h2><p>Start simple. If you don't have a lot of services, a static revocation list read at startup (from a file, or an environment variable) can be more than enough. Then you can think about out-of-band polling, or even push notifications. Try to keep things simple, you don't want too many moving parts. Just keep in mind that if you end up calling a central revocation service every time you're checking a token, you might be better off with a centralized session.</p><h2 id="but-seriously-consider-using-biscuit">But seriously, consider using <a href="https://biscuitsec.org">biscuit</a></h2><p><a href="https://biscuitsec.org">Biscuits</a> have been designed with macaroons strengths (and weaknesses) in mind, so they tend to provide out of the box all the mitigations required by macaroons. For instance they provide unique revocation ids as part of the spec and as such as part of the core API.</p>
                </div>
            </section>
